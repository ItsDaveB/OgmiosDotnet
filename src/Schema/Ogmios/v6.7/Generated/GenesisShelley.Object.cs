//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

using System.Collections.Immutable;
using System.Text.Json;
using Corvus.Json;
using Corvus.Json.Internal;

namespace Generated;
/// <summary>
/// Genesis<Shelley>
/// </summary>
/// <remarks>
/// <para>
/// A Shelley genesis configuration, with information used to bootstrap the era. Some parameters are also updatable across the era.
/// </para>
/// </remarks>
public readonly partial struct GenesisShelley
    : IJsonObject<Generated.GenesisShelley>
{
    /// <summary>
    /// Conversion from <see cref="ImmutableList{JsonObjectProperty}"/>.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator GenesisShelley(ImmutableList<JsonObjectProperty> value)
    {
        return new(value);
    }

    /// <summary>
    /// Conversion to <see cref="ImmutableList{JsonObjectProperty}"/>.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator ImmutableList<JsonObjectProperty>(GenesisShelley value)
    {
        return
            __CorvusObjectHelpers.GetPropertyBacking(value);
    }

    /// <summary>
    /// Conversion from JsonObject.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator GenesisShelley(JsonObject value)
    {
        if (value.HasDotnetBacking && value.ValueKind == JsonValueKind.Object)
        {
            return new(
                __CorvusObjectHelpers.GetPropertyBacking(value));
        }

        return new(value.AsJsonElement);
    }

    /// <summary>
    /// Conversion to JsonObject.
    /// </summary>
    /// <param name="value">The value from which to convert.</param>
    public static implicit operator JsonObject(GenesisShelley value)
    {
        return
            value.AsObject;
    }

    /// <inheritdoc/>
    public Corvus.Json.JsonAny this[in JsonPropertyName name]
    {
        get
        {
            if (this.TryGetProperty(name, out Corvus.Json.JsonAny result))
            {
                return result;
            }

            throw new InvalidOperationException();
        }
    }

    /// <summary>
    /// Gets the number of properties in the object.
    /// </summary>
    public int Count
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                return this.jsonElementBacking.GetPropertyCount();
            }

            if ((this.backing & Backing.Object) != 0)
            {
                return this.objectBacking.Count;
            }

            throw new InvalidOperationException();
        }
    }

    /// <summary>
    /// Gets the <c>activeSlotsCoefficient</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// <para>
    /// A ratio of two integers, to express exact fractions.
    /// </para>
    /// </remarks>
    public Generated.Ratio ActiveSlotsCoefficient
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.ActiveSlotsCoefficientUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.ActiveSlotsCoefficient, out JsonAny result))
                {
                    return result.As<Generated.Ratio>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>epochLength</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// <para>
    /// An epoch number or length.
    /// </para>
    /// </remarks>
    public Generated.Epoch EpochLength
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.EpochLengthUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.EpochLength, out JsonAny result))
                {
                    return result.As<Generated.Epoch>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>era</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.GenesisShelley.EraEntity Era
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.EraUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.Era, out JsonAny result))
                {
                    return result.As<Generated.GenesisShelley.EraEntity>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>initialDelegates</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.InitialDelegates InitialDelegates
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.InitialDelegatesUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.InitialDelegates, out JsonAny result))
                {
                    return result.As<Generated.InitialDelegates>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>initialFunds</c> property.
    /// InitialFunds
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.GenesisShelley.InitialFunds InitialFundsValue
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.InitialFundsValueUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.InitialFundsValue, out JsonAny result))
                {
                    return result.As<Generated.GenesisShelley.InitialFunds>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>initialParameters</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.ProtocolParameters InitialParameters
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.InitialParametersUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.InitialParameters, out JsonAny result))
                {
                    return result.As<Generated.ProtocolParameters>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>initialStakePools</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// <para>
    /// A Genesis stake pools configuration; primarily used for bootstrapping test networks.
    /// </para>
    /// </remarks>
    public Generated.GenesisStakePools InitialStakePools
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.InitialStakePoolsUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.InitialStakePools, out JsonAny result))
                {
                    return result.As<Generated.GenesisStakePools>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>maxKesEvolutions</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.UInt64 MaxKesEvolutions
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.MaxKesEvolutionsUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.MaxKesEvolutions, out JsonAny result))
                {
                    return result.As<Generated.UInt64>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>maxLovelaceSupply</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.UInt64 MaxLovelaceSupply
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.MaxLovelaceSupplyUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.MaxLovelaceSupply, out JsonAny result))
                {
                    return result.As<Generated.UInt64>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>network</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// <para>
    /// A network target, as defined since the Shelley era.
    /// </para>
    /// </remarks>
    public Generated.Network Network
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.NetworkUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.Network, out JsonAny result))
                {
                    return result.As<Generated.Network>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>networkMagic</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// <para>
    /// A magic number for telling networks apart. (e.g. 764824073)
    /// </para>
    /// </remarks>
    public Generated.NetworkMagic NetworkMagic
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.NetworkMagicUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.NetworkMagic, out JsonAny result))
                {
                    return result.As<Generated.NetworkMagic>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>securityParameter</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.UInt64 SecurityParameter
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.SecurityParameterUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.SecurityParameter, out JsonAny result))
                {
                    return result.As<Generated.UInt64>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>slotLength</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// <para>
    /// A slot length in milliseconds
    /// </para>
    /// </remarks>
    public Generated.SlotLength SlotLength
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.SlotLengthUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.SlotLength, out JsonAny result))
                {
                    return result.As<Generated.SlotLength>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>slotsPerKesPeriod</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.UInt64 SlotsPerKesPeriod
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.SlotsPerKesPeriodUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.SlotsPerKesPeriod, out JsonAny result))
                {
                    return result.As<Generated.UInt64>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>startTime</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.UtcTime StartTime
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.StartTimeUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.StartTime, out JsonAny result))
                {
                    return result.As<Generated.UtcTime>();
                }
            }

            return default;
        }
    }

    /// <summary>
    /// Gets the <c>updateQuorum</c> property.
    /// </summary>
    /// <remarks>
    /// <para>
    /// If the instance is valid, this property will not be <see cref="JsonValueKind.Undefined"/>.
    /// </para>
    /// </remarks>
    public Generated.UInt64 UpdateQuorum
    {
        get
        {
            if ((this.backing & Backing.JsonElement) != 0)
            {
                if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
                {
                    return default;
                }

                if (this.jsonElementBacking.TryGetProperty(JsonPropertyNames.UpdateQuorumUtf8, out JsonElement result))
                {
                    return new(result);
                }
            }

            if ((this.backing & Backing.Object) != 0)
            {
                if (this.objectBacking.TryGetValue(JsonPropertyNames.UpdateQuorum, out JsonAny result))
                {
                    return result.As<Generated.UInt64>();
                }
            }

            return default;
        }
    }

    /// <inheritdoc/>
    public static GenesisShelley FromProperties(IDictionary<JsonPropertyName, JsonAny> source)
    {
        return new(source.Select(kvp => new JsonObjectProperty(kvp.Key, kvp.Value)).ToImmutableList());
    }

    /// <inheritdoc/>
    public static GenesisShelley FromProperties(params (JsonPropertyName Name, JsonAny Value)[] source)
    {
        return new(source.Select(s => new JsonObjectProperty(s.Name, s.Value.AsAny)).ToImmutableList());
    }

    /// <summary>
    /// Creates an instance of the type from the given immutable list of properties.
    /// </summary>
    /// <param name="source">The list of properties.</param>
    /// <returns>An instance of the type initialized from the list of properties.</returns>
    public static GenesisShelley FromProperties(ImmutableList<JsonObjectProperty> source)
    {
        return new(source);
    }

    /// <summary>
    /// Creates an instance of a <see cref="GenesisShelley"/>.
    /// </summary>
    public static GenesisShelley Create(
        in Generated.Ratio activeSlotsCoefficient,
        in Generated.Epoch epochLength,
        in Generated.GenesisShelley.EraEntity era,
        in Generated.InitialDelegates initialDelegates,
        in Generated.GenesisShelley.InitialFunds initialFundsValue,
        in Generated.ProtocolParameters initialParameters,
        in Generated.GenesisStakePools initialStakePools,
        in Generated.UInt64 maxKesEvolutions,
        in Generated.UInt64 maxLovelaceSupply,
        in Generated.Network network,
        in Generated.NetworkMagic networkMagic,
        in Generated.UInt64 securityParameter,
        in Generated.SlotLength slotLength,
        in Generated.UInt64 slotsPerKesPeriod,
        in Generated.UtcTime startTime,
        in Generated.UInt64 updateQuorum)
    {
        var builder = ImmutableList.CreateBuilder<JsonObjectProperty>();
        builder.Add(JsonPropertyNames.ActiveSlotsCoefficient, activeSlotsCoefficient.AsAny);
        builder.Add(JsonPropertyNames.EpochLength, epochLength.AsAny);
        builder.Add(JsonPropertyNames.Era, era.AsAny);
        builder.Add(JsonPropertyNames.InitialDelegates, initialDelegates.AsAny);
        builder.Add(JsonPropertyNames.InitialFundsValue, initialFundsValue.AsAny);
        builder.Add(JsonPropertyNames.InitialParameters, initialParameters.AsAny);
        builder.Add(JsonPropertyNames.InitialStakePools, initialStakePools.AsAny);
        builder.Add(JsonPropertyNames.MaxKesEvolutions, maxKesEvolutions.AsAny);
        builder.Add(JsonPropertyNames.MaxLovelaceSupply, maxLovelaceSupply.AsAny);
        builder.Add(JsonPropertyNames.Network, network.AsAny);
        builder.Add(JsonPropertyNames.NetworkMagic, networkMagic.AsAny);
        builder.Add(JsonPropertyNames.SecurityParameter, securityParameter.AsAny);
        builder.Add(JsonPropertyNames.SlotLength, slotLength.AsAny);
        builder.Add(JsonPropertyNames.SlotsPerKesPeriod, slotsPerKesPeriod.AsAny);
        builder.Add(JsonPropertyNames.StartTime, startTime.AsAny);
        builder.Add(JsonPropertyNames.UpdateQuorum, updateQuorum.AsAny);

        return new(builder.ToImmutable());
    }

    /// <inheritdoc/>
    public ImmutableList<JsonObjectProperty> AsPropertyBacking()
    {
        return __CorvusObjectHelpers.GetPropertyBacking(this);
    }
    /// <inheritdoc/>
    public ImmutableList<JsonObjectProperty>.Builder AsPropertyBackingBuilder()
    {
        return __CorvusObjectHelpers.GetPropertyBacking(this).ToBuilder();
    }

    /// <inheritdoc/>
    public JsonObjectEnumerator EnumerateObject()
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            return new(this.jsonElementBacking);
        }

        if ((this.backing & Backing.Object) != 0)
        {
            return new(this.objectBacking);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc/>
    public bool HasProperties()
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.Count > 0;
        }

        if ((this.backing & Backing.JsonElement) != 0)
        {
            using JsonElement.ObjectEnumerator enumerator = this.jsonElementBacking.EnumerateObject();
            return enumerator.MoveNext();
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool HasProperty(in JsonPropertyName name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(name);
        }

        if ((this.backing & Backing.JsonElement) != 0)
        {
            return name.TryGetProperty(this.jsonElementBacking, out JsonElement _);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool HasProperty(string name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(name);
        }

        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.TryGetProperty(name, out _);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool HasProperty(ReadOnlySpan<char> name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(name);
        }

        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.TryGetProperty(name, out _);
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool HasProperty(ReadOnlySpan<byte> name)
    {
        if ((this.backing & Backing.Object) != 0)
        {
            return this.objectBacking.ContainsKey(name);
        }

        if ((this.backing & Backing.JsonElement) != 0)
        {
            return this.jsonElementBacking.TryGetProperty(name, out _);
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(in JsonPropertyName name, out JsonAny value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (name.TryGetProperty(this.jsonElementBacking, out JsonElement element))
            {
                value = new(element);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
                value = result;
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(string name, out JsonAny value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement element))
            {
                value = new(element);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
                value = result;
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(ReadOnlySpan<char> name, out JsonAny value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement element))
            {
                value = new(element);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
                value = result;
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <summary>
    /// Get a property.
    /// </summary>
    /// <param name="name">The name of the property.</param>
    /// <param name="value">The value of the property.</param>
    /// <returns><c>True</c> if the property was present.</returns>
    /// <exception cref="InvalidOperationException">The value is not an object.</exception>
    public bool TryGetProperty(ReadOnlySpan<byte> name, out JsonAny value)
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement element))
            {
                value = new(element);
                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
                value = result;
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool TryGetProperty<TValue>(in JsonPropertyName name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (name.TryGetProperty(this.jsonElementBacking, out JsonElement element))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(element);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(element);
#endif

                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool TryGetProperty<TValue>(string name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement element))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(element);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(element);
#endif

                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool TryGetProperty<TValue>(ReadOnlySpan<char> name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement element))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(element);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(element);
#endif

                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public bool TryGetProperty<TValue>(ReadOnlySpan<byte> name, out TValue value)
        where TValue : struct, IJsonValue<TValue>
    {
        if ((this.backing & Backing.JsonElement) != 0)
        {
            if (this.jsonElementBacking.ValueKind != JsonValueKind.Object)
            {
                value = default;
                return false;
            }

            if (this.jsonElementBacking.TryGetProperty(name, out JsonElement element))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromJson(element);
#else
                value = JsonValueNetStandard20Extensions.FromJsonElement<TValue>(element);
#endif

                return true;
            }

            value = default;
            return false;
        }

        if ((this.backing & Backing.Object) != 0)
        {
            if (this.objectBacking.TryGetValue(name, out JsonAny result))
            {
#if NET8_0_OR_GREATER
                value = TValue.FromAny(result);
#else
                value = result.As<TValue>();
#endif
                return true;
            }

            value = default;
            return false;
        }

        throw new InvalidOperationException();
    }

    /// <inheritdoc />
    public GenesisShelley SetProperty<TValue>(in JsonPropertyName name, TValue value)
        where TValue : struct, IJsonValue
    {
        return new(__CorvusObjectHelpers.GetPropertyBackingWith(this, name, value.AsAny));
    }

    /// <inheritdoc />
    public GenesisShelley RemoveProperty(in JsonPropertyName name)
    {
        return new(__CorvusObjectHelpers.GetPropertyBackingWithout(this, name));
    }

    /// <inheritdoc />
    public GenesisShelley RemoveProperty(string name)
    {
        return new(__CorvusObjectHelpers.GetPropertyBackingWithout(this, name));
    }

    /// <inheritdoc />
    public GenesisShelley RemoveProperty(ReadOnlySpan<char> name)
    {
        return new(__CorvusObjectHelpers.GetPropertyBackingWithout(this, name));
    }

    /// <inheritdoc />
    public GenesisShelley RemoveProperty(ReadOnlySpan<byte> name)
    {
        return new(__CorvusObjectHelpers.GetPropertyBackingWithout(this, name));
    }

    /// <summary>
    /// Provides UTF8 and string versions of the JSON property names on the object.
    /// </summary>
    public static class JsonPropertyNames
    {
        /// <summary>
        /// Gets the JSON property name for <see cref="ActiveSlotsCoefficient"/>.
        /// </summary>
        public const string ActiveSlotsCoefficient = "activeSlotsCoefficient";

        /// <summary>
        /// Gets the JSON property name for <see cref="EpochLength"/>.
        /// </summary>
        public const string EpochLength = "epochLength";

        /// <summary>
        /// Gets the JSON property name for <see cref="Era"/>.
        /// </summary>
        public const string Era = "era";

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialDelegates"/>.
        /// </summary>
        public const string InitialDelegates = "initialDelegates";

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialFundsValue"/>.
        /// </summary>
        public const string InitialFundsValue = "initialFunds";

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialParameters"/>.
        /// </summary>
        public const string InitialParameters = "initialParameters";

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialStakePools"/>.
        /// </summary>
        public const string InitialStakePools = "initialStakePools";

        /// <summary>
        /// Gets the JSON property name for <see cref="MaxKesEvolutions"/>.
        /// </summary>
        public const string MaxKesEvolutions = "maxKesEvolutions";

        /// <summary>
        /// Gets the JSON property name for <see cref="MaxLovelaceSupply"/>.
        /// </summary>
        public const string MaxLovelaceSupply = "maxLovelaceSupply";

        /// <summary>
        /// Gets the JSON property name for <see cref="Network"/>.
        /// </summary>
        public const string Network = "network";

        /// <summary>
        /// Gets the JSON property name for <see cref="NetworkMagic"/>.
        /// </summary>
        public const string NetworkMagic = "networkMagic";

        /// <summary>
        /// Gets the JSON property name for <see cref="SecurityParameter"/>.
        /// </summary>
        public const string SecurityParameter = "securityParameter";

        /// <summary>
        /// Gets the JSON property name for <see cref="SlotLength"/>.
        /// </summary>
        public const string SlotLength = "slotLength";

        /// <summary>
        /// Gets the JSON property name for <see cref="SlotsPerKesPeriod"/>.
        /// </summary>
        public const string SlotsPerKesPeriod = "slotsPerKesPeriod";

        /// <summary>
        /// Gets the JSON property name for <see cref="StartTime"/>.
        /// </summary>
        public const string StartTime = "startTime";

        /// <summary>
        /// Gets the JSON property name for <see cref="UpdateQuorum"/>.
        /// </summary>
        public const string UpdateQuorum = "updateQuorum";

        /// <summary>
        /// Gets the JSON property name for <see cref="ActiveSlotsCoefficient"/>.
        /// </summary>
        public static ReadOnlySpan<byte> ActiveSlotsCoefficientUtf8 => "activeSlotsCoefficient"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="EpochLength"/>.
        /// </summary>
        public static ReadOnlySpan<byte> EpochLengthUtf8 => "epochLength"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="Era"/>.
        /// </summary>
        public static ReadOnlySpan<byte> EraUtf8 => "era"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialDelegates"/>.
        /// </summary>
        public static ReadOnlySpan<byte> InitialDelegatesUtf8 => "initialDelegates"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialFundsValue"/>.
        /// </summary>
        public static ReadOnlySpan<byte> InitialFundsValueUtf8 => "initialFunds"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialParameters"/>.
        /// </summary>
        public static ReadOnlySpan<byte> InitialParametersUtf8 => "initialParameters"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="InitialStakePools"/>.
        /// </summary>
        public static ReadOnlySpan<byte> InitialStakePoolsUtf8 => "initialStakePools"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="MaxKesEvolutions"/>.
        /// </summary>
        public static ReadOnlySpan<byte> MaxKesEvolutionsUtf8 => "maxKesEvolutions"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="MaxLovelaceSupply"/>.
        /// </summary>
        public static ReadOnlySpan<byte> MaxLovelaceSupplyUtf8 => "maxLovelaceSupply"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="Network"/>.
        /// </summary>
        public static ReadOnlySpan<byte> NetworkUtf8 => "network"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="NetworkMagic"/>.
        /// </summary>
        public static ReadOnlySpan<byte> NetworkMagicUtf8 => "networkMagic"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="SecurityParameter"/>.
        /// </summary>
        public static ReadOnlySpan<byte> SecurityParameterUtf8 => "securityParameter"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="SlotLength"/>.
        /// </summary>
        public static ReadOnlySpan<byte> SlotLengthUtf8 => "slotLength"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="SlotsPerKesPeriod"/>.
        /// </summary>
        public static ReadOnlySpan<byte> SlotsPerKesPeriodUtf8 => "slotsPerKesPeriod"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="StartTime"/>.
        /// </summary>
        public static ReadOnlySpan<byte> StartTimeUtf8 => "startTime"u8;

        /// <summary>
        /// Gets the JSON property name for <see cref="UpdateQuorum"/>.
        /// </summary>
        public static ReadOnlySpan<byte> UpdateQuorumUtf8 => "updateQuorum"u8;
    }

    private static class __CorvusObjectHelpers
    {
        /// <summary>
        /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object.
        /// </summary>
        /// <returns>An immutable list of <see cref="JsonAny"/> built from the object.</returns>
        /// <exception cref="InvalidOperationException">The value is not an object.</exception>
        public static ImmutableList<JsonObjectProperty> GetPropertyBacking(in GenesisShelley that)
        {
            if ((that.backing & Backing.Object) != 0)
            {
                return that.objectBacking;
            }

            if ((that.backing & Backing.JsonElement) != 0)
            {
                return PropertyBackingBuilders.GetPropertyBackingBuilder(that.jsonElementBacking).ToImmutable();
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
        /// </summary>
        /// <returns>An immutable list of <see cref="JsonObjectProperty"/>, built from the existing object, without the given property.</returns>
        /// <exception cref="InvalidOperationException">The value is not an object.</exception>
        public static ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(in GenesisShelley that, in JsonPropertyName name)
        {
            if ((that.backing & Backing.Object) != 0)
            {
                return that.objectBacking.Remove(name);
            }

            if ((that.backing & Backing.JsonElement) != 0)
            {
                return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(that.jsonElementBacking, name).ToImmutable();
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
        /// </summary>
        /// <returns>An immutable list of <see cref="JsonObjectProperty"/>, built from the existing object, without the given property.</returns>
        /// <exception cref="InvalidOperationException">The value is not an object.</exception>
        public static ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(in GenesisShelley that, ReadOnlySpan<char> name)
        {
            if ((that.backing & Backing.Object) != 0)
            {
                return that.objectBacking.Remove(name);
            }

            if ((that.backing & Backing.JsonElement) != 0)
            {
                return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(that.jsonElementBacking, name).ToImmutable();
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
        /// </summary>
        /// <returns>An immutable list of <see cref="JsonObjectProperty"/>, built from the existing object, without the given property.</returns>
        /// <exception cref="InvalidOperationException">The value is not an object.</exception>
        public static ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(in GenesisShelley that, ReadOnlySpan<byte> name)
        {
            if ((that.backing & Backing.Object) != 0)
            {
                return that.objectBacking.Remove(name);
            }

            if ((that.backing & Backing.JsonElement) != 0)
            {
                return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(that.jsonElementBacking, name).ToImmutable();
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
        /// </summary>
        /// <returns>An immutable list of <see cref="JsonObjectProperty"/>, built from the existing object, without the given property.</returns>
        /// <exception cref="InvalidOperationException">The value is not an object.</exception>
        public static ImmutableList<JsonObjectProperty> GetPropertyBackingWithout(in GenesisShelley that, string name)
        {
            if ((that.backing & Backing.Object) != 0)
            {
                return that.objectBacking.Remove(name);
            }

            if ((that.backing & Backing.JsonElement) != 0)
            {
                return PropertyBackingBuilders.GetPropertyBackingBuilderWithout(that.jsonElementBacking, name).ToImmutable();
            }

            throw new InvalidOperationException();
        }

        /// <summary>
        /// Builds an <see cref="ImmutableList{JsonObjectProperty}"/> from the object, without a specific property.
        /// </summary>
        /// <returns>An immutable list of <see cref="JsonObjectProperty"/>, built from the existing object, with the given property.</returns>
        /// <exception cref="InvalidOperationException">The value is not an object.</exception>
        public static ImmutableList<JsonObjectProperty> GetPropertyBackingWith(in GenesisShelley that, in JsonPropertyName name, in JsonAny value)
        {
            if ((that.backing & Backing.Object) != 0)
            {
                return that.objectBacking.SetItem(name, value);
            }

            if ((that.backing & Backing.JsonElement) != 0)
            {
                return PropertyBackingBuilders.GetPropertyBackingBuilderReplacing(that.jsonElementBacking, name, value).ToImmutable();
            }

            throw new InvalidOperationException();
        }
    }
}
